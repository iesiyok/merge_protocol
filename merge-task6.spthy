theory merge_task6
begin


builtins: hashing, signing
functions: h/1
restriction Equality:	"All x y #i. Eq(x, y) @i ==> x = y"
restriction	Inequality: "All x #i. Neq(x,x) @ #i ==> F"
// functions: hash/1
// equations: hash(<hd, tl>)= h(<hd, hash(tl)>) 
// equations: hash(<r, '0'>)=h(<r, 'nil'>)

//public key register
rule Reg:
  [Fr(~k)] --[ Reveal_p($A)]-> [ !Pub_k($A, pk(~k)), !Priv_k($A, ~k), Out( pk(~k))]  


//initialize the input x and give ~sid to agent U
rule initialize:
	let x = <m1, m2, '0'>
	in
	[Fr(~sid)]--[Init(~sid)]->[Prot_loop(~sid, x, x, 'nil')]

//in the end of this loop, we are going to get hash_x= h(<m2, h(m1, 'nil')>), org_x=<m1,m2,'0'>
rule start:
	let x = <hd, tl>
	    m = <hd, ph>
	    hash_x = h(m)
	 in
	[Prot_loop(sid, org_x, x, ph)]--[Neq(hd, '0'), Protocol_Start(sid)]->[Prot_loop(sid, org_x, tl, hash_x)]

//initialize the agent U's state with the information from previous rules
rule U_1_loop_start:
 let prev_h = 'nil'
 in
 	[Prot_loop(sid, org_x, tl, hash_x)] --[Start(sid)]-> [ !U_1_Loop(org_x, prev_h), !State(sid, $U, hash_x)]

//U's sender loop
rule U_1_loop:
 let m = <hd, ph>
     e = h(m)		  
     sig = sign(e, ~k )
 in
 [	 !Priv_k(U, ~k) 
 , 	 !U_1_Loop(<hd, tl>, ph)
 ,	 !State(sid, U, hash_x) //sid is being hold in order to be unique
 ]
 --[ Neq(hd, '0'),
 	 U_1_St(sid, U, e) //fact -- message has been sent
 ]->[
 	 Out( <e, sig>)	
 ,   U_1_Send(U, hd, e)	
 ,	 !U_1_Loop(tl, e)
 ]	

//receiver W 
rule W:
 let v = verify(sig, e, pkU)
     sig2 = sign(e, kW)	
 in 									
 [	 !Pub_k(U, pkU), !Priv_k(W, kW)
 ,   In(<e, sig>)	
 ]
 --[ Eq(v,true), W_Rcv(U, W, e)		// fact -- message has been received
 ]->
 [   Out(<e, sig2>)
 ]

 //U-2 user receive 
rule U_2:
 let e = h(<r, ph>)
 	 v = verify(sig, e, pkW)
 in
 [	//if the received message from W equals to the message that was sent in the first place
 	 !Pub_k(W, pkW), !State(sid, U, hash_x), U_1_Send(U, r, e)			//r is the message that was sent in the first place	
 ,   In(<e, sig>)
 ]
 --[ Eq(v, true)
 ,	 Accept(sid, U, W, e)		//ACCEPT under these circumstances
 ]->
 [	Accepted(sid, U, W, e) ]	


rule retrieved_all:
[	//if the last message accepted by agent U, 
	//then its hash must be equal to the hash of whole message which is h(<m2, h(m1, 'nil')>) in this case 
	 Accepted(sid, U, W, e), !State(sid, U, e) //e = hash_x
]--[ All_Retrieved(sid, U, W, e) //ALL messages retrieved
]->[]

/*INITIALIZATION PART*/

//init must start first
lemma init_before_prot_start [reuse, use_induction]:
  "All sid #j. Protocol_Start(sid)@j ==> (Ex #i. Init(sid)@i & i < j)"

//Init must start before, U initizalizes its parameters
lemma init_before_U_start:
  "All sid #j. Start(sid)@j ==> (Ex #i. Init(sid)@i & i < j)"

//the loop that calculates the hash of whole messages must start before U initializes its parameters
lemma prot_start_before_U_start [reuse, use_induction]:
  "All sid #i #j. Start(sid)@j & Protocol_Start(sid)@i ==> #i < #j"

//U must be unique
lemma U_start_unique [reuse]:
  "All sid #i #j. Start(sid)@j & Start(sid)@i ==> #i = #j"  

/*MESSAGE SEND, RECEIVE AND ACCEPT PART*/ 

//The order is problematic from this stage !!

//to start to send message, U's parameters must be initialized 
lemma start_before_U_send_start [reuse, use_induction]:
 "All U e sid #j. U_1_St(sid, U, e)@j ==> (Ex #i. Start(sid)@i & i < j)"

//All_Retrieved requires that last message was accepted !! This is problematic!
lemma accept_before_all_retrieved [reuse, use_induction]:
  "All U W e sid #i #j. All_Retrieved(sid, U, W, e)@j & Accept(sid, U, W, e)@i ==> #i < #j"

//U's Accept requires the message coming from W
lemma W_recv_before_accept [reuse, use_induction]:
  "All U W e sid #i #j. Accept(sid, U, W, e)@j & W_Rcv(U, W, e)@i ==> #i < #j"

//W's receive requires the message sent by U
lemma U_start_before_W_recv [reuse, use_induction]:
  "All U W e #j. W_Rcv(U, W, e)@j ==> (Ex sid #i. U_1_St(sid, U, e)@i & i < j)"


//to accept a message it must be sent in the first place
lemma U_start_before_accept [reuse, use_induction]:
  "All U W e sid #j. Accept(sid, U, W, e)@j ==> (Ex #i. U_1_St(sid, U, e)@i & i < j)"

//A message accept must be unique
lemma accept_unique [reuse]:
  "All U W e sid #i #j. Accept(sid, U, W, e)@j & Accept(sid, U, W, e)@i ==> #i = #j"  

//All messages retrieved must work only once
lemma all_retrieved_unique [reuse]:
  "All U W e sid #i #j. All_Retrieved(sid, U, W, e)@j & All_Retrieved(sid, U, W, e)@i ==> #i = #j"  




end